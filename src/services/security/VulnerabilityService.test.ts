import { describe, it, expect, vi, beforeEach } from 'vitest';
import { VulnerabilityService, createVulnerabilityService } from './VulnerabilityService';
import type { DatabaseService } from '../database/DatabaseService';

// Mock AuditLogger
vi.mock('./AuditLogger', () => ({
  createAuditLogger: () => ({
    log: vi.fn().mockResolvedValue(undefined),
    logAdminAction: vi.fn().mockResolvedValue(undefined),
  }),
}));

function createMockDb(): DatabaseService {
  return {
    select: vi.fn().mockResolvedValue({ data: [], error: null }),
    insert: vi.fn().mockResolvedValue({ data: null, error: null }),
    update: vi.fn().mockResolvedValue({ data: null, error: null }),
    delete: vi.fn().mockResolvedValue({ data: null, error: null }),
  } as unknown as DatabaseService;
}

describe('VulnerabilityService', () => {
  let db: ReturnType<typeof createMockDb>;
  let service: VulnerabilityService;

  beforeEach(() => {
    db = createMockDb();
    service = new VulnerabilityService(db);
  });

  // ─── createVulnerability ──────────────────────────────────────────────
  describe('createVulnerability', () => {
    it('creates vulnerability with generated id and timestamp', async () => {
      const vulnData = {
        severity: 'HIGH' as const,
        category: 'DEPENDENCY' as const,
        title: 'Test Vuln',
        description: 'A test vulnerability',
        affectedComponent: 'lodash@4.17.0',
        status: 'OPEN' as const,
        tags: ['test'],
      };

      const result = await service.createVulnerability(vulnData, 'user-1');
      expect(result.id).toMatch(/^vuln-/);
      expect(result.discoveredAt).toBeTruthy();
      expect(result.severity).toBe('HIGH');
      expect(result.title).toBe('Test Vuln');
      expect(db.insert).toHaveBeenCalledWith('vulnerabilities', expect.objectContaining({ severity: 'HIGH' }));
    });

    it('sets CVSS score and CVE id when provided', async () => {
      const vulnData = {
        severity: 'CRITICAL' as const,
        category: 'DEPENDENCY' as const,
        title: 'Critical CVE',
        description: 'desc',
        affectedComponent: 'openssl',
        cveId: 'CVE-2024-1234',
        cvssScore: 9.8,
        status: 'OPEN' as const,
        tags: ['critical'],
      };

      const result = await service.createVulnerability(vulnData, 'scanner');
      expect(result.cveId).toBe('CVE-2024-1234');
      expect(result.cvssScore).toBe(9.8);
    });
  });

  // ─── runDependencyScan ────────────────────────────────────────────────
  describe('runDependencyScan', () => {
    it('returns COMPLETED scan with vulnerability counts', async () => {
      const scan = await service.runDependencyScan('admin-1');
      expect(scan.type).toBe('DEPENDENCY');
      expect(scan.status).toBe('COMPLETED');
      expect(scan.vulnerabilitiesFound).toBeGreaterThan(0);
      expect(scan.highCount).toBeGreaterThanOrEqual(1);
      expect(scan.completedAt).toBeTruthy();
      expect(scan.duration).toBeGreaterThanOrEqual(0);
    });

    it('stores discovered vulnerabilities in database', async () => {
      await service.runDependencyScan('admin-1');
      // Should insert at least 2 mock vulnerabilities (lodash + validator)
      expect(db.insert).toHaveBeenCalled();
      const insertCalls = (db.insert as ReturnType<typeof vi.fn>).mock.calls;
      const vulnInserts = insertCalls.filter((c) => c[0] === 'vulnerabilities');
      expect(vulnInserts.length).toBeGreaterThanOrEqual(2);
    });

    it('returns FAILED scan when database insert throws', async () => {
      (db.insert as ReturnType<typeof vi.fn>).mockRejectedValue(new Error('DB write error'));

      const scan = await service.runDependencyScan('admin-1');
      expect(scan.status).toBe('FAILED');
      expect(scan.vulnerabilitiesFound).toBe(0);
    });
  });

  // ─── runComplianceScan ────────────────────────────────────────────────
  describe('runComplianceScan', () => {
    it('runs HIPAA compliance checks', async () => {
      const scan = await service.runComplianceScan('admin-1', 'HIPAA');
      expect(scan.type).toBe('COMPLIANCE');
      expect(scan.status).toBe('COMPLETED');
      // HIPAA mock has 1 NON_COMPLIANT item
      expect(scan.vulnerabilitiesFound).toBeGreaterThanOrEqual(1);
    });

    it('runs GDPR compliance checks', async () => {
      const scan = await service.runComplianceScan('admin-1', 'GDPR');
      expect(scan.status).toBe('COMPLETED');
    });

    it('runs SOC2 compliance checks with zero non-compliant', async () => {
      const scan = await service.runComplianceScan('admin-1', 'SOC2');
      expect(scan.status).toBe('COMPLETED');
      // SOC2 mocks are all COMPLIANT
      expect(scan.vulnerabilitiesFound).toBe(0);
    });

    it('returns FAILED on exception', async () => {
      (db.insert as ReturnType<typeof vi.fn>).mockRejectedValue(new Error('insert error'));

      const scan = await service.runComplianceScan('admin-1', 'HIPAA');
      expect(scan.status).toBe('FAILED');
    });
  });

  // ─── runComplianceChecks ──────────────────────────────────────────────
  describe('runComplianceChecks', () => {
    it('returns checks for HIPAA standard', async () => {
      const checks = await service.runComplianceChecks('HIPAA');
      expect(checks.length).toBe(4);
      expect(checks.every((c) => c.standard === 'HIPAA')).toBe(true);
    });

    it('returns checks for GDPR standard', async () => {
      const checks = await service.runComplianceChecks('GDPR');
      expect(checks.length).toBe(3);
    });

    it('returns empty for unknown standard', async () => {
      const checks = await service.runComplianceChecks('UNKNOWN');
      expect(checks.length).toBe(0);
    });
  });

  // ─── updateVulnerabilityStatus ────────────────────────────────────────
  describe('updateVulnerabilityStatus', () => {
    it('updates status successfully', async () => {
      (db.update as ReturnType<typeof vi.fn>).mockResolvedValue({ data: {}, error: null });

      const result = await service.updateVulnerabilityStatus('vuln-1', 'RESOLVED', 'admin-1', 'Fixed in v2');
      expect(result.success).toBe(true);
    });

    it('returns error on update failure', async () => {
      (db.update as ReturnType<typeof vi.fn>).mockResolvedValue({ data: null, error: 'Not found' });

      const result = await service.updateVulnerabilityStatus('vuln-bad', 'RESOLVED', 'admin-1');
      expect(result.success).toBe(false);
      expect(result.error).toBe('Not found');
    });

    it('returns error on exception', async () => {
      (db.update as ReturnType<typeof vi.fn>).mockRejectedValue(new Error('Timeout'));

      const result = await service.updateVulnerabilityStatus('vuln-1', 'IN_PROGRESS', 'admin-1');
      expect(result.success).toBe(false);
      expect(result.error).toBe('Timeout');
    });
  });

  // ─── getVulnerabilities ───────────────────────────────────────────────
  describe('getVulnerabilities', () => {
    it('returns mapped vulnerabilities from database', async () => {
      const dbRows = [
        {
          id: 'v1',
          severity: 'HIGH',
          category: 'DEPENDENCY',
          title: 'Test',
          description: 'desc',
          affected_component: 'pkg@1.0',
          cve_id: 'CVE-2024-0001',
          cvss_score: 7.5,
          discovered_at: '2024-01-01',
          status: 'OPEN',
          tags: ['test'],
        },
      ];
      (db.select as ReturnType<typeof vi.fn>).mockResolvedValue({ data: dbRows, error: null });

      const results = await service.getVulnerabilities();
      expect(results.length).toBe(1);
      expect(results[0].affectedComponent).toBe('pkg@1.0');
      expect(results[0].cveId).toBe('CVE-2024-0001');
    });

    it('passes severity filters to database query', async () => {
      (db.select as ReturnType<typeof vi.fn>).mockResolvedValue({ data: [], error: null });

      await service.getVulnerabilities({ severity: ['CRITICAL', 'HIGH'] });
      expect(db.select).toHaveBeenCalledWith(
        'vulnerabilities',
        expect.objectContaining({ filters: expect.objectContaining({ severity: ['CRITICAL', 'HIGH'] }) })
      );
    });

    it('returns empty array on error', async () => {
      (db.select as ReturnType<typeof vi.fn>).mockRejectedValue(new Error('fail'));
      const results = await service.getVulnerabilities();
      expect(results).toEqual([]);
    });
  });

  // ─── generateSecurityReport ───────────────────────────────────────────
  describe('generateSecurityReport', () => {
    it('generates report with vulnerability breakdown and recommendations', async () => {
      const dbRows = [
        {
          id: 'v1',
          severity: 'CRITICAL',
          category: 'DEPENDENCY',
          title: 'A',
          description: '',
          affected_component: 'x',
          discovered_at: '',
          status: 'OPEN',
          tags: [],
        },
        {
          id: 'v2',
          severity: 'HIGH',
          category: 'CODE',
          title: 'B',
          description: '',
          affected_component: 'y',
          discovered_at: '',
          status: 'OPEN',
          tags: [],
        },
        {
          id: 'v3',
          severity: 'MEDIUM',
          category: 'DEPENDENCY',
          title: 'C',
          description: '',
          affected_component: 'z',
          discovered_at: '',
          status: 'OPEN',
          tags: [],
        },
      ];
      (db.select as ReturnType<typeof vi.fn>).mockResolvedValue({ data: dbRows, error: null });

      const report = await service.generateSecurityReport('admin-1');
      expect(report.vulnerabilities.total).toBe(3);
      expect(report.vulnerabilities.critical).toBe(1);
      expect(report.vulnerabilities.high).toBe(1);
      expect(report.vulnerabilities.medium).toBe(1);
      expect(report.vulnerabilities.byCategory['DEPENDENCY']).toBe(2);
      expect(report.compliance.hipaaCompliance).toBe(75);
      expect(report.recommendations.length).toBeGreaterThan(0);
    });
  });

  // ─── factory function ─────────────────────────────────────────────────
  describe('createVulnerabilityService', () => {
    it('returns a VulnerabilityService instance', () => {
      const svc = createVulnerabilityService(db);
      expect(svc).toBeInstanceOf(VulnerabilityService);
    });
  });
});
